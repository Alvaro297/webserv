**Persona A Alvaro**

**Persona B Dani**

**Persona C Mario**

Si terminais algo marcarlo ya sea en negrita con un listo o tachandolo (No lo quiteis)

---

## üë• Reparto del equipo

| Persona | Rol | M√≥dulos principales |
|---------|-----|---------------------|
| üß† **A** (Core Networking) | Infraestructura del servidor y gesti√≥n de sockets/eventos | Server, Client, PollManager |
| ‚öôÔ∏è **B** (HTTP Engine) | Parsing de peticiones, respuestas y status codes | Request, Response, HttpHandler |
| üóÇÔ∏è **C** (Config + CGI) | Configuraci√≥n .conf, filesystem, CGI y autoindex | ConfigParser, CGIHandler, FileManager |

---

## üìÜ Semana 1 ‚Äî Fundamentos y base del servidor

### Persona A (Networking)
- **‚úÖ Implementar clase Server que abra sockets y escuche**
- **‚úÖ Aceptar conexiones (bloqueante al principio)**
- **‚úÖ Montar estructura del bucle principal (poll() o kqueue())**
- **‚úÖ Estructurar proyecto: carpetas, Makefile, namespaces**
- **‚úÖ Crear clase Client con fd y buffers b√°sicos**
- **‚úÖ Sockets non-blocking con fcntl(O_NONBLOCK)**
- **‚úÖ SO_REUSEADDR para reutilizar puertos**

### Persona B (HTTP Engine)
- **‚úÖ Dise√±ar clases Request y Response (headers, body, status code)
- **‚úÖ Entender y resumir RFC 2616 (HTTP/1.1)
- **‚úÖ Implementar parsing b√°sico de una request simple (GET)
- **‚úÖ Definir interfaz entre A y B (c√≥mo recibir raw request)

### Persona C (Config + Files)
- **‚úÖ Crear parser b√°sico de configuraci√≥n (server { ... })**
- **‚úÖ Leer archivo .conf y almacenar hosts, puertos, root, etc.**
- **‚úÖ Documentar formato de config para el equipo**
- **‚úÖ Clase ServerConfig con getters/setters**

### üéØ Objetivo semana 1:
**‚úÖ Servidor levanta, acepta conexiones y detecta datos**  
**‚úÖ Estructura de c√≥digo lista**  
**‚úÖ Responde "Hello World" b√°sico** (hardcoded, esperando parser HTTP de Persona B)

---

## üìÜ Semana 2 ‚Äî HTTP funcional y multiplexaci√≥n

### Persona A (Networking)
- **‚úÖ Convertir el servidor a no bloqueante**
- **‚úÖ Implementar poll() din√°mico para listeners + clientes**
- **‚úÖ Crear clase Client con readBuffer/writeBuffer**
- **‚úÖ Detectar request HTTP completa (\r\n\r\n)**
- **‚úÖ isListener() para distinguir listeners de clientes**
- ‚è≥ Pasar request completa a Persona B (integraci√≥n pendiente - esperando a Dani)
- **‚úÖ Implementar writeClient() con send() para enviar respuestas**
- **‚úÖ Limpiar readBuffer despu√©s de procesar**
- **‚úÖ Manejar errores EAGAIN/EWOULDBLOCK correctamente**

### Persona B (HTTP Engine)
- **‚úÖ Completar parsing HTTP: m√©todo, URI, versi√≥n, headers, body
- **‚úÖ Implementar GET correctamente con rutas
- ‚è≥ Crear respuestas din√°micas con headers y c√≥digos (200, 404, etc.)
- **‚úÖ Validar requests malformadas (400 Bad Request)
- **‚úÖ Manejar Content-Length para POST
- **‚úÖ Definir estructura Request con m√©todos p√∫blicos

### Persona C (Config + Files)
- **‚úÖ Completar ConfigParser (m√∫ltiples servidores, locations)**
- **‚úÖ Asociar rutas con configuraci√≥n (root, index, error_page)**
- ‚è≥ Servir archivos est√°ticos (index.html, im√°genes, etc.)
- ‚è≥ Implementar b√∫squeda de archivos index
- ‚è≥ MIME types b√°sicos (html, css, js, jpg, png)
- ‚è≥ Manejar permisos de lectura (403 Forbidden)

### üéØ Objetivo semana 2:
**‚úÖ Servidor puede servir p√°ginas est√°ticas a m√∫ltiples clientes concurrentes** (listo para integraci√≥n con Persona B)
‚è≥ Configuraci√≥n personalizada funciona (depende de Persona C)
‚è≥ GET funcional con archivos del disco (depende de Persona B + C)

---

## üìÜ Semana 3 ‚Äî M√©todos HTTP completos y CGI

### Persona A (Networking)
- **‚úÖ Implementar timeouts de conexi√≥n (detectar clientes inactivos)**
- **‚úÖ Manejar POLLOUT para escritura cuando buffer est√° lleno**
- **‚úÖ Gesti√≥n limpia de cierres (close() y erase() de _client) - closeClient() centralizado**
- **‚úÖ Manejar SIGPIPE (ignorar, no crashear) - signal(SIGPIPE, SIG_IGN)**
- **‚úÖ poll() con timeout de 1000ms para chequeos regulares**
- **‚úÖ lastActivity tracking en Client class**

### Persona B (HTTP Engine)
- ‚è≥ Implementar POST con body completo
- ‚è≥ Implementar DELETE (borrado de archivos)
- ‚è≥ Validar client_max_body_size
- ‚è≥ Implementar c√≥digos de error: 400, 403, 404, 405, 413, 500, 501, 505
- ‚è≥ Parsing de Query String (?param=value)
- ‚è≥ Gestionar uploads de archivos (multipart/form-data b√°sico)

### Persona C (Config + CGI)
- ‚è≥ Implementar CGIHandler:
  - Ejecutar scripts (al menos 1 lenguaje: PHP o Python)
  - fork() + execve() + pipes
  - Leer stdout del proceso CGI
  - Parsear headers CGI (Status:, Content-Type:)
  - Timeout para scripts que se cuelgan
- ‚è≥ Variables de entorno CGI (REQUEST_METHOD, QUERY_STRING, etc.)
- ‚è≥ Implementar autoindex (listado de directorios)
- ‚è≥ Redirecciones (return 301/302)
- ‚è≥ Directiva limit_except (m√©todos permitidos por location)

### üéØ Objetivo semana 3:
‚è≥ Servidor sirve archivos, procesa POST y DELETE  
‚è≥ CGI funcional con al menos un lenguaje  
‚è≥ Pasa tests b√°sicos del subject

---

## üìÜ Semana 4 ‚Äî Refinamiento, testing y subject completo

### Persona A (Networking)
- ‚è≥ Revisar fugas de memoria (valgrind --leak-check=full)
- ‚è≥ Verificar cierres de sockets (lsof, netstat)
- ‚è≥ Testear con siege/ab/wrk (stress test 100+ clientes)
- **‚úÖ Manejar SIGPIPE (ignorar, no crashear)** - ya implementado en Semana 3
- ‚è≥ Logs de debug (conexiones, errores, timeouts)
- **‚úÖ Verificar que poll() se llama solo una vez por iteraci√≥n** - verificado
- ‚è≥ Garantizar que el servidor NUNCA cuelga indefinidamente

### Persona B (HTTP Engine)
- ‚è≥ Revisar conformidad RFC 2616 (o HTTP/1.0 como referencia)
- ‚è≥ Casos edge: headers largos, body vac√≠o, m√©todo desconocido
- ‚è≥ Validar con navegadores reales (Chrome, Firefox)
- ‚è≥ Probar con Postman/Insomnia (POST, DELETE)
- ‚è≥ Documentar API interna (c√≥mo a√±adir m√©todos nuevos)

### Persona C (Config + CGI + Files)
- ‚è≥ Verificar error_page personalizadas
- ‚è≥ Revisar CGI con extensi√≥n elegida (.php o .py)
- ‚è≥ Testear autoindex y permisos
- ‚è≥ Documentar formato .conf completo con ejemplos
- ‚è≥ Proporcionar archivos de configuraci√≥n y archivos de prueba

### Testing conjunto
- ‚è≥ Script de tests automatizado (bash + curl)
- ‚è≥ 20-30 casos t√≠picos del subject
- ‚è≥ Tests de evaluadores anteriores
- ‚è≥ Preparar defensa: explicar arquitectura, decisiones, manejo de errores

### üéØ Objetivo semana 4:
‚è≥ Servidor estable, sin leaks, sin crashes  
‚è≥ Pasa todos los tests del subject  
‚è≥ Preparado para evaluaci√≥n

---

## ‚úÖ Checklist completa del Subject (MANDATORY ONLY)

> **IMPORTANTE:** Esta secci√≥n contiene SOLO los requisitos OBLIGATORIOS del subject. Los bonus est√°n en secci√≥n separada m√°s abajo.

### HTTP/1.1 Core
- [ ] HTTP/1.1 compliant (RFC 2616 como referencia, HTTP/1.0 sugerido pero no obligatorio)
- [ ] M√©todos: GET, POST, DELETE
- [ ] Response con status code correcto (200, 404, 500, etc.)
- [ ] Headers de request/response correctos
- [ ] Manejo de body en POST

### Configuraci√≥n
- [x] Archivo .conf estilo nginx (Persona C)
- [x] M√∫ltiples server blocks (Persona C)
- [x] listen (puerto) (Persona C)
- [x] root (directorio base) (Persona C)
- [x] index (archivos por defecto) (Persona C)
- [x] error_page (p√°ginas de error personalizadas) (Persona C)
- [ ] client_max_body_size (l√≠mite de tama√±o)
- [x] location blocks con: (Persona C)
  - [x] root o alias
  - [ ] limit_except (m√©todos permitidos)
  - [ ] return (redirecciones)
  - [ ] autoindex on/off
- [ ] **Ejecutable debe tomar [archivo de configuraci√≥n] como argumento**
- [ ] **Proporcionar archivos de configuraci√≥n y archivos de prueba**

> **Nota del subject sobre Virtual Hosting:** "We deliberately chose to offer only a subset of the HTTP RFC. In this context, the virtual host feature is considered out of scope. But you are allowed to implement it if you want." ‚Üí **NO ES OBLIGATORIO**

### Archivos est√°ticos
- [ ] Servir archivos HTML, CSS, JS, im√°genes
- [ ] MIME types correctos (Content-Type)
- [ ] B√∫squeda de index files
- [ ] Autoindex (listado de directorio)
- [ ] Manejo de permisos (403 si no se puede leer)
- [ ] **Servir una p√°gina web completamente est√°tica**

### CGI (OBLIGATORIO - al menos 1 tipo)
- [ ] Ejecutar CGI con al menos una extensi√≥n (.php, .py, o .pl)
- [ ] Variables de entorno CGI correctas:
  - REQUEST_METHOD
  - QUERY_STRING
  - CONTENT_LENGTH
  - CONTENT_TYPE
  - PATH_INFO
  - SCRIPT_FILENAME
- [ ] Pipes stdin/stdout con proceso CGI
- [ ] Parsear headers que devuelve el CGI (Status:, Content-Type:, etc.)
- [ ] Timeout para CGI que se cuelga
- [ ] **Un-chunking de requests chunked antes de pasar a CGI** (el CGI espera EOF)
- [ ] **Manejo de respuestas CGI sin Content-Length** (EOF marca el final)
- [ ] **Ejecutar CGI en el directorio correcto** (para rutas relativas)
- [ ] **fork() SOLO para CGI** (no para otras cosas)

### Upload de archivos
- [ ] POST con multipart/form-data
- [ ] Clientes pueden subir archivos
- [ ] Guardar archivos en directorio configurado (o configuraci√≥n de d√≥nde almacenarlos)
- [ ] Respetar client_max_body_size

### Non-blocking I/O (CR√çTICO - SUSPENDES SI NO CUMPLES)
- [x] poll() o select() o kqueue() o epoll() (Persona A)
- [x] **Solo UNA llamada a poll/select/etc. por iteraci√≥n** (Persona A - verificado)
- [x] Non-blocking sockets (fcntl O_NONBLOCK) (Persona A)
- [x] Manejo correcto de EAGAIN/EWOULDBLOCK (Persona A)
- [x] **Nunca leer/escribir en sockets sin pasar por poll()** (Persona A)
- [ ] **Archivos de disco regulares (open/read/write) NO requieren poll()** (permitido bloqueante)
- [x] **Monitoring simult√°neo de lectura Y escritura** con poll() (Persona A)
- [x] **El servidor debe permanecer non-blocking en todo momento** (Persona A)

> **CR√çTICO del subject:** "I/O that can wait for data (sockets, pipes/FIFOs, etc.) must be non-blocking and driven by a single poll() (or equivalent). Calling read/recv or write/send on these descriptors without prior readiness will result in a grade of 0. Regular disk files are exempt."

### Robustez (CR√çTICO)
- [ ] **No crashear NUNCA** (stress test con siege/ab)
- [ ] **Sin leaks de memoria** (valgrind)
- [x] **Manejo de se√±ales** (SIGPIPE ignorado) (Persona A)
- [x] **Timeouts de conexi√≥n** (requests no pueden colgar indefinidamente) (Persona A)
- [ ] **Servidor disponible en todo momento** (stress test)
- [ ] **Compatibilidad con navegadores est√°ndar** (Chrome, Firefox, Safari)
- [ ] **No usar execve() para otro servidor web**
- [ ] **Manejar correctamente desconexiones de clientes**
- [ ] **Comprobar valor de errno PROHIBIDO despu√©s de read/write**

> **Importante:** "A request to your server should never hang indefinitely."

> **Importante:** "Checking the value of errno to adjust the server behaviour is strictly forbidden after performing a read or write operation."

### C√≥digos de error HTTP
- [ ] 200 OK
- [ ] 201 Created (POST exitoso)
- [ ] 204 No Content (DELETE exitoso)
- [ ] 301 Moved Permanently (redirect)
- [ ] 302 Found (redirect temporal)
- [ ] 400 Bad Request (request malformada)
- [ ] 403 Forbidden (sin permisos)
- [ ] 404 Not Found
- [ ] 405 Method Not Allowed (limit_except)
- [ ] 413 Payload Too Large (client_max_body_size)
- [ ] 500 Internal Server Error
- [ ] 501 Not Implemented (m√©todo no soportado)
- [ ] 505 HTTP Version Not Supported
- [ ] **P√°ginas de error por defecto si no se proporcionan**

### Puertos m√∫ltiples
- [x] **Servidor debe poder escuchar en m√∫ltiples puertos** (Persona A + C)
- [x] **Servir contenido diferente seg√∫n el puerto** (Persona C - configuraci√≥n)

### Compilaci√≥n y Makefile
- [x] Flags: -Wall -Wextra -Werror
- [x] Reglas: all, clean, fclean, re
- [x] Compila sin warnings
- [x] C++98 compliant
- [x] NAME del ejecutable: webserv
- [ ] **Uso:** `./webserv [configuration file]`

---

## üåü BONUS PART (Secci√≥n oficial del Subject)

> **‚ö†Ô∏è IMPORTANTE:** Los bonus SOLO se eval√∫an si la parte MANDATORY est√° PERFECTA. No comiences bonus hasta que TODO lo de arriba est√© 100% funcional y testeado sin errores.

> **Nota del subject:** "Here are some additional features you can implement:"

### 1. **Cookies y gesti√≥n de sesiones** üç™
- [ ] Implementar `Set-Cookie:` en respuestas HTTP
- [ ] Leer header `Cookie:` en requests
- [ ] Gesti√≥n b√°sica de sesiones (session ID)
- [ ] **Proporcionar ejemplos simples de uso** (requisito expl√≠cito del subject)

**Responsable sugerido:** Persona B (HTTP Engine)

**Dificultad:** Media (3-5 horas)

**Ejemplo pr√°ctico requerido:**
```http
Response del servidor:
HTTP/1.1 200 OK
Set-Cookie: sessionid=abc123; Path=/; HttpOnly

Request siguiente del cliente:
GET /profile HTTP/1.1
Cookie: sessionid=abc123
```

---

### 2. **M√∫ltiples tipos de CGI** üîß
- [ ] Soportar **m√°s de un tipo** de CGI (PHP, Python, Perl)
- [ ] Configuraci√≥n por extensi√≥n (.php, .py, .pl)
- [ ] Variables de entorno correctas para cada tipo
- [ ] Tests con scripts reales de cada lenguaje

> **Nota:** El mandatory solo requiere 1 tipo de CGI. Este bonus requiere **m√∫ltiples tipos** (al menos 2 o m√°s).

**Responsable sugerido:** Persona C (Config + CGI)

**Dificultad:** F√°cil-Media (2-4 horas si ya tienes 1 CGI funcionando)

**Ejemplo de configuraci√≥n:**
```nginx
location ~ \.php$ {
    cgi_pass /usr/bin/php-cgi;
}
location ~ \.py$ {
    cgi_pass /usr/bin/python3;
}
location ~ \.pl$ {
    cgi_pass /usr/bin/perl;
}
```

---

## üìã Mejoras opcionales (NO son bonus oficiales)

Estas caracter√≠sticas NO est√°n en el subject como bonus, pero mejoran el servidor. **No las hagas hasta tener mandatory + bonus oficiales perfectos.**

- [ ] Chunked Transfer Encoding (request y response)
- [ ] Keep-Alive / Persistent connections (Connection: keep-alive)
- [ ] Content-Range (partial downloads / resume)
- [ ] If-Modified-Since (caching b√°sico HTTP)
- [ ] Logs detallados con timestamps estilo nginx
- [ ] Compression gzip (Accept-Encoding / Content-Encoding)
- [ ] Autoindex mejorado (HTML bonito con iconos)
- [ ] Custom error pages mejoradas (variables din√°micas)
- [ ] Virtual Hosting completo (server_name + Host header)
- [ ] L√≠mite de clientes simult√°neos configurable

---

## ‚öôÔ∏è Pr√°cticas recomendadas

### Comunicaci√≥n
- **Reuni√≥n corta diaria (15 min)** ‚Üí estado, bloqueos, decisiones
- **Documentar decisiones importantes** en carpeta `/docs`
- **Interfaz clara entre A-B-C** (archivo INTERFACE.md)

### Git workflow
- **Branches claras:** `feature/network`, `feature/http`, `feature/config`
- **Merge solo tras code review** entre personas
- **Commits descriptivos:** "feat: add chunked encoding" no "fix stuff"

### Testing continuo
- **Tester propio:** script bash con curl -v para 20‚Äì30 casos
- **Valgrind diario:** `valgrind --leak-check=full ./webserv`
- **Stress test semanal:** `siege -c100 -r10 http://localhost:8080`

### Debugging
- **Logs con niveles:** DEBUG, INFO, ERROR
- **Compilar con -g** para gdb/lldb
- **Verificar fds abiertos:** `lsof -p $(pidof webserv)`

---

## üìö Recursos √∫tiles

- **RFC 2616 (HTTP/1.1):** https://www.rfc-editor.org/rfc/rfc2616
- **RFC 1945 (HTTP/1.0):** https://www.rfc-editor.org/rfc/rfc1945 (sugerido como referencia)
- **Nginx config docs:** https://nginx.org/en/docs/
- **CGI 1.1 spec:** https://www.rfc-editor.org/rfc/rfc3875
- **Beej's Guide to Network Programming:** https://beej.us/guide/bgnet/
- **HTTP status codes:** https://httpstatuses.com/

> **Consejo del subject:** "If you have a question about a specific behaviour, you can compare your program's behaviour with NGINX's."

---

## üêõ Problemas comunes y soluciones

### "Address already in use"
```bash
sudo pkill -9 webserv
# O a√±adir SO_REUSEADDR al socket (ya implementado ‚úÖ)
```

### "poll() debe llamarse solo una vez por iteraci√≥n"
```cpp
// ‚úÖ Correcto:
while (true) {
    // preparar fds
    int ready = poll(&fds[0], fds.size(), timeout);  // UNA sola llamada
    // procesar eventos
}

// ‚ùå Incorrecto (nota 0):
while (true) {
    poll(...);  // Primera llamada
    // ...
    poll(...);  // Segunda llamada - PROHIBIDO
}
```

### "read/write sin poll() previo"
```cpp
// ‚ùå Incorrecto (nota 0):
recv(fd, buffer, size, 0);  // Sin verificar POLLIN antes

// ‚úÖ Correcto:
if (fds[i].revents & POLLIN) {
    recv(fds[i].fd, buffer, size, 0);
}
```

### "Archivos de disco vs sockets"
```cpp
// ‚úÖ Archivos regulares NO necesitan poll():
int fd = open("file.html", O_RDONLY);  // Bloqueante OK
read(fd, buffer, size);                 // Sin poll() OK
close(fd);

// ‚ùå Sockets/pipes S√ç necesitan poll():
int socket_fd = accept(...);
// NO HACER: read(socket_fd, ...) directamente
// CORRECTO: esperar POLLIN con poll()

```
